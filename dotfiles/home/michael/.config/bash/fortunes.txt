Steal a solution.
List the qualities it has. List those you'd like.
How would you explain this to: your parents? a child?
Back up a few steps. What else could you have done?
Who is it for?
What do you do best?
What most recently impressed you? How is it similar? What can you learn from it? What could you take from it?
Take away as much mystery as possible. What is left?
Pay attention to distractions
Commit to the next thing that occurs to you.
Resurrect a dead idea
Don't be afraid to repeat yourself.
Follow the path of least resistance
Enjoy the absence of a clear solution.
If in doubt, improvise.
Never run if you can walk.
Abandon it, but come back to it later
Quality thought is a result of quality time.
Second guess your doubts, triple guess your initial thoughts.
What is the least important thing right now?
Avoid repetition at all costs.
Cut your losses.
If you can't walk, try running.
Break it down into smaller parts.
If all you have is a hammer, everything looks like a nail.
Research.
Look for an old or new solution.
Are you using the best tool for the job?
Think about what you really feel like doing, then do it.
Spend some time looking at art or listening to music and don't think about it.
Form a few different hypotheses and test them.
Evaluate your goals.
Evaluate your progress. Look for ways to improve.
Trim the fat.
Do something unnecessary.
Take a quick nap.
Try something completely new.
Make it up as you go.
Meditate for a while.
Abandon normal instructions
Accept advice
Adding on
Always the first steps
Ask your body
Be dirty
Be extravagant
Be less critical
Breathe more deeply
Bridges - build - burn
Change ambiguities to specifics
Change nothing and continue consistently
Change specifics to ambiguities
Consider transitions
Discard an axiom
Disciplined self-indulgence
Discover your formulas and abandon them
Display your talent
Do nothing for as long as possible
Don't avoid what is easy
Don't stress one thing more than another
Do something boring
Do something sudden, destructive and unpredictable
Do the last thing first
Do the words need changing?
Emphasize differences
Emphasize the flaws
Faced with a choice, do both
Find a safe part and use it as an anchor
Give the game away
Go outside. Shut the door.
Go to an extreme, come part way back
How would someone else do it?
How would you have done it?
Is it finished?
Is something missing?
Is the style right?
It is simply a matter of work
Just carry on
Listen to the quiet voice
Look at the order in which you do things
Magnify the most difficult details
Make what's perfect more human
Move towards the unimportant
Not building a wall; making a brick
Once the search has begun, something will be found
Only a part, not the whole
Only one element of each kind
Openly resist change
Remove a restriction
Repetition is a form of change
Retrace your steps
Slow preparation, fast execution
State the problem as clearly as possible
Take a break
Take away the important parts
The most easily forgotten thing is the most important
Think - inside the work - outside the work
Tidy up
Try faking it
Turn it upside down
Use an old idea
Use something nearby as a model
Use your own ideas
Voice your suspicions
What context would look right?
What is the simplest solution?
What mistakes did you make last time?
What to increase? What to reduce? What to maintain?
What were you really thinking about just now?
What wouldn't you do?
What would your closest friend do?
When is it for?
Where is the edge?
Which parts can be grouped?
Work at a different speed
Would anyone want it?
Your mistake was a hidden intention
Look for a hack. Cut corners.
Relax the problem wherever possible.
Look for a good enough approximation.
Use a novel combination of high-level strategies.
Forget about optimizing your code. You can always leave a TODO and fix it later.
Solve the problem directly.
The lazy man lifts more than he can safely carry, to save the trouble of coming a second time.
Take as much time as you need to study the problem and design the solution.
Get red and green right before mixing yellow.
A blink lasts 300 milliseconds.
Add constraints.
Verify your fears, explicitly.
If you see ten troubles coming down the road, you can be sure that nine will run into the ditch before they reach you.
Take a closer look.
Is it the bug you think it is?
Is it a typo? Did you copy and paste?
Stop and think it through first.
If you lack motivation, find the most interesting thing in the project, start on that, and branch from there.
Work append-only. Don't worry about mistakes, you can clean it up later.
Change your mind.
Look for ways to chain tools.
Backtrack. If an avenue appears exhausted, your assumption must be wrong.
You cannot dig a hole in a different place by digging the same hole deeper.
Flip the problem around. Look at it from a different perspective.
Work forward from where the unfinished part of the code suggests you should.
List dependencies to determine the order of completion.
Try the naive method first.
Implementing both solutions can be faster than theorising over which is best.
Verify your assumptions.
Get water flowing through the pipe. Connect the system end-to-end, using dummy sections where necessary. The pieces that are finished yield testable output.
Write down everything you know about the problem.
If you're stuck, finish some remaining piece. Then go back and check to see what new possibilities opened up. Repeat.
It is often better to guess wrong and check than to sit pondering what might be correct.
Have goals and subdivide them.
...truth will sooner come out of error than from confusion.
Do something - inaction won't solve the problem.
Work on something else.
Make an exhaustive list of everything you might do next.
Remember that models don't necessarily correspond with reality.
Generate alternative solutions and pick the best.
Can you make this program do one thing instead of two?
Is this abstraction delivering enough benefit?
Are you solving the right problem?
Can you automate this?
If it doesn't work, it doesn't matter how fast it doesn't work.
Are you clear about what you are trying to build?
Could the documentation be wrong?
Does the code actually do what the comments say it should?
Can you build something to help you understand the problem?
Before software can be reusable it first has to be usable.
First, solve the problem. Then, write the code.
Deleted code is debugged code.
Is it broken by design?
Sit quietly and think.
KISS: Keep It Short and Simple. Keep It Simple Stupid!
What would be the implications of ignoring this problem and doing nothing about it for the time being?
The simplest explanation is most likely the correct one.
Can you get more information?
Is there a test or simulation that you could run?
Is this really necessary?
Can I simplify the problem somehow?
Only change one thing at a time. Try to predict what will happen with each change.
Stop guessing and look at the facts.
Are you fooling yourself?
Write some more unit tests.
Keep a written log of every change and any results.
Is there a better algorithm? Consult the literature.
Idly thumb through The Gang of Four Design Patterns book.
Idly thumb through The Art of Computer Science by Donald Knuth.
Designing the right data structure is often more important than designing the right code.
How could you go about formally proving this code to be correct?
Is this code part of a design pattern? What's its name?
Get away from your desk.
Collect all the information, notes, scribbles and diagrams.
Tidy up your work area.
Are you looking in the right place?
Is this a symptom or a cause?
Take a break
Try recreating this section from scratch.
Try to write a small, reproducible code sample with just the salient parts and all other complexity removed.
Is this a numerical problem? Think about rounding, division by zero, overflow and floating point errors.
Is there a standard approach to this?
If you had time to refactor this code, what would you change?
Can you pair program it?
How did they do it without computers?
Don't assume that the bug was caused by somebody else.
Build expertise in your project's domain. Talk to expert users. Read industry papers, academic reports, brochures etc.
Read a book on the subject.
Take a smoke break, even if you don't actually smoke.
Make a cup of tea or coffee.
Don't invent another data format.
Go outside and get some fresh air.
Stand in front of a big blank whiteboard with a pen. Start writing.
What's the simplest thing that could possibly work?
Think about what is going on at the lowest possible level and work your way up.
Read it slowly, carefully and deliberately. What does it actually say?
Write down a clear statement of the problem on paper.
Can you find some similar code in an open source project and study it?
Go and talk to somebody who isn't a programmer.
Switch off your monitor and sit at your desk quietly for a while.
Go and get something to eat.
Google it.
Can you reuse an old idea or code from an earlier project?
Sleep on it. Things will look different tomorrow.
Imagine what the world would look like if you had already solved the problem.
Are you using the right tools for the job?
Do your names and abstractions correspond with the real world? Is your code model driven?
Do it manually.
Every problem has a perfectly reasonable explanation.
Can you use a tool to get a better idea what's happening?
Don't reinvent the wheel. If there's a library, use it.
Can you adapt something that you already have?
Read the documentation thoroughly. Read it again.
Imagine you had unlimited resources. What would you do?
Have you seen it with your own eyes?
Is it worth the effort? What else could you be doing?
Quickly weigh the costs and benefits, then decide.
What is true of one part may not be true of the whole.
What is true of the whole may not be true of one part.
What goals do you have right now? How long will they take?
The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time.
Perfect is the enemy of good.
Do one thing well, not many things poorly.
Don't hesitate to start again if necessary. It will probably save you time.
Good programmers know what to write. Great ones know what to rewrite and reuse.
Perfection in design is achieved when there is nothing more to take away.
Commit early and often.
It is better to have a system omit certain anomalous features and improvements, but to reflect one set of design ideas, than to have one that contains many good but independent and uncoordinated ideas
